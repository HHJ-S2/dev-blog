---
date: '2022-09-12'
title: '클래스(Class) - 상속과 재정의'
categories: ['TIL', 'Swift']
summary: '클래스(Class) - 상속과 재정의'
---

## 상속

```swift
class Person {
  var id = 0
  var name = "이름"
  var email = "abc@def.com"
}

final class Student: Person {
  // 상속받은 id, name, email 이 존재함
  var studentId = 0
}

let student1 = Student()

student1.name = "Any"
student1.name // "Any"
```

상속은 성격이 비슷한 새로운 타입을 만들때, 데이터(저장속성)을 추가하거나 메서드를 변형해서 사용하고싶을때 주로 사용한다.

상속은 클래스에서만 가능하다.(구조체는 불가능)

저장속성은 각각의 속성별로 저장공간이 따로 있고, 하위클래스에서는 상속받은 저장속성을 변경할 수 없지만, 메서드는 변형이 가능하다.

<br/>

어떤 클래스도 상속받지 않은 클래스를 기본(Base)클래스, 부모 클래스, 슈퍼클래스, 상위클래스 라고 한다.

상속을 받은 클래스는 자식클래스, 서브클래스, 하위클래스라고 한다.

<br/>

더이상 상속을 할 수 없도록 지정하고 싶을때는 `final` 키워드를 표기한다. (저장속성에도 가능)

<br/>

생성자의 경우 상속되지 않는다. 재정의의 경우 원칙적으로 불가하나 깊게 알아보면 방법이 있는것 같은데 아직 잘 모르겠음.

<br/>

## 재정의

```swift
class 에스프레소 {
  var 금액 = 3000

  var 가격정보: Int {
    get {
      return 금액
    }
    set {
      self.금액 = newValue
    }
  }

  func 만들기() {
    print("샷을 두개 내립니다.")
  }
}

class 라떼: 에스프레소 {
  var 오늘의커피할인 = 500

  override var 가격정보: Int {
    get {
      return super.금액
    }
    set {
      super.금액 = newValue - 오늘의커피할인
    }
  }

  //  속성감시자 추가도 가능.
  //  override var 가격정보: Int {
  //    didSet(금액) {
  //      print("가격이 \(금액)에서 \(self.금액)로 변경되었습니다.")
  //    }
  //  }

  override func 만들기() {
    super.만들기()
    print("샷에 우유를 추가합니다.")
  }
}

var 라떼한잔 = 라떼()
라떼한잔.만들기()

라떼한잔.가격정보 = 4500
라떼한잔.금액 // 4000
```

클래스의 메서드의 경우 `override` 키워드를 표기하여 하위클래스에서 상위클래스의 메서드 변형이 가능하며

이렇게 변형 하는것을 <b>재정의</b> 라고 한다. (계산속성도 가능)

상속받은 메서드를 호출할경우 `super` 키워드로 접근한다. `super.만들기()`

<br/>

## 클래스에서 생성자의 상속이 일어나는 경우

```swift
class AClass {
  var x: Int
  var y: Int

  init(x: Int, y: Int) {
    self.x = x
    self.y = y
  }
}

class BClass: AClass {
  var z: Int

  // 저장속성 추가시 지정생성자로 구현
  init(x: Int, y: Int, z: Int) {
    self.z = z // 1. 내 저장속성의 값을 초기화 ⭐️
    super.init(x: x, y: y) // 2. 상속받은 지정생성자 초기화 ⭐️
  }

  // 저장속성을 추가하지 않고 상위클래스의 지정생성자만 재정의 하는경우 override
  //  override init(x: Int, y: Int) {
  //    super.init(x: x, y: y)
  //  }

  // 편의생성자로 구현
  convenience init() {
    self.init(x: 0, y: 0, z: 0) // 1. 자신의 지정생성자 초기화 ⭐️
  }
}
```

지정생성자는 하위클래스에 상속이 되지 않기때문에 상속을 받은 하위클래스에서 초기화를 해주어야 하는것이 필수다.

즉, 하위클래스에서 상위 클래스의 초기화되지 않은 생성자에 접근하려면 `super.init` 으로 꼭 상위의 지정생성자를 호출해주어야 한다.

편의생성자의 경우 자신의 지정생성자를 호출해주어야 하고, 하위클래스에서는 상위클래스의 편의생성자를 재정의 할 수 없다.

<br/>

#### 1️⃣ 상위 클래스의 지정생성자 체크

<br/>

#### 2️⃣ 상속받은 하위클래스에서 저장속성을 추가하는지 체크

<br/>

#### 추가해야하는 저장속성이 있는경우

1. 내 저장속성의 값을 초기화
2. 상속받은 지정생성자 초기화

#### 추가해야하는 저장속성이 없는경우

1. `override` 로 상위클래스의 지정생성자만 초기화

<br/>

#### 3️⃣ 상속을받은 하위클래스에서 편의생성자를 추가하는 경우 주의

1. 하위클래스에서 `override` 로 편의생성자를 추가하는경우 편의생성자에서 `self.init`을 하는것은 상위가 아니라 나 자신의 지정생성자를 호출하는것이다.

<br/>

결론은... 모든 지정생성자를 초기화 해주어야 인스턴스 사용이 가능하다.
